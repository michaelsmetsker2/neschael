/*
	simple script, generates the metatiles file based on the collision from tiled and map from nexxt,
  build with 
  gcc -o generateMetatiles generateMetatiles.c
*/

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#define MAX_METATILES 256
#define LINE_SIZE 16
#define WIDTH 32
#define HEIGHT 32
#define SIZE (WIDTH * HEIGHT)

typedef struct {
  uint8_t t1;
  uint8_t t2;
  uint8_t b1;
  uint8_t b2;
} Metatile;

int main() {
 
  uint8_t tiles[SIZE] = {0};
  uint8_t collision[SIZE] = {0};

  Metatile mTiles[MAX_METATILES];
  
  char line[1024];            // max line size when reading from file
	
  FILE *fptr = fopen("../data/tiles/raw/metas.asm", "r");
	
	if (!fptr) {
    fprintf(stderr, "couldn't find/open metas.asm\n");
		return 1;
	}
	
	// throw away the first line (filename)
  fgets(line, sizeof(line), fptr);

  int index = 0;
  while (fgets(line, sizeof(line), fptr)) {  
		
    // only grab the numbers
    for (char *p = line; *p;) {
      if (*p++ == '$') {
        tiles[index++] = (uint8_t)strtol(p, NULL, 16); // and store them in the matrix
      }
		}
	}
  fclose(fptr);  

  // get collision date from tiled file
  FILE *collptr = fopen("./tiled/metas.tsx", "r");

  if (!collptr) {
    fprintf(stderr, "couldn't find/open metas.tsx\n");
    return 1;
  }

  index = 0;
  while (fgets(line, sizeof(line), collptr)) {

    char *p = line;

    if ((p = strstr(p, "value=\"")) != NULL) {

      p += 7; // increment past value="
      collision[index++] = (uint8_t)strtol(p, NULL, 10);
    }
  }
  fclose(collptr);

  // find the ammount of valid metatiles and add the, to the struct array
  int metaCount = 0;
  for(int mRow = 0; mRow < 16; mRow++) {
    for(int mCol = 0; mCol < 16; mCol++) {
      
      int row = mRow * 2;
      int col = mCol * 2;
      
      mTiles[metaCount].t1 = tiles[row * WIDTH + col];
      mTiles[metaCount].t2 = tiles[row * WIDTH + col + 1];
      mTiles[metaCount].b1 = tiles[(row + 1) * WIDTH + col];
      mTiles[metaCount].b2 = tiles[(row + 1) * WIDTH + col + 1];

      if (mRow == 0 && mCol == 0) { // skip the first empty metatile
        metaCount++;
        continue;
      }


			if (!mTiles[metaCount].t1 && !mTiles[metaCount].t2 && 
          !mTiles[metaCount].b1 && !mTiles[metaCount].b2
        ) {
          break;
      }
      
			metaCount++;
		}
	}


  FILE *out = fopen("../data/tiles/metatiles.s", "w");
  //FILE *out = fopen("metatiles.s", "w");
  if (!out) {
    fprintf(stderr, "counldn't open output file");
    return 1;
  }
  // print and format ===================================================================================

  // print header
  fprintf(out, ";\n; neschael\n; data/tiles/metatiles.s\n;\n; file generated by tools/generateMetatiles.c\n; contains metatile definitions\n; order: t1 t2 b1 b2\n;\n\n");
  fprintf(out, ".EXPORT metatiles\n\n");
  
  // lookup table
  fprintf(out, "metatiles:\n\t.WORD ");
  for (int i = 0; i < metaCount; i++) {
    if (i) {
      fprintf(out, ", ");
    }
    fprintf(out, "tile_%i", i);
  }

  // print tile
  for (int i =0; i < metaCount; i++) {
    fprintf(out, "\n\ntile_%i:\n", i);

    //print tiles
    fprintf(out, "\t.BYTE ");
    fprintf(out, "$%02X, $%02X, $%02X, $%02X ", mTiles[i].t1, mTiles[i].t2, mTiles[i].b1, mTiles[i].b2);


    //print collision
    fprintf(out, "\n\t.BYTE "); 
    int colIndex = i * 4;
    fprintf(out, "$%02X, $%02X, $%02X, $%02X ", collision[colIndex], collision[colIndex+1], collision[colIndex+2], collision[colIndex+3]);

  }

  fclose(out);
	return 0;
}